Ext.data.JsonP.advance({"guide":"<h1>Advanced Techniques</h1>\n<div class='toc'>\n<p><strong>Contents</strong></p>\n<ol>\n<li><a href='#!/guide/advance-section-1'>The Report API</a></li>\n<li><a href='#!/guide/advance-section-2'>The Big Try-Catch</a></li>\n<li><a href='#!/guide/advance-section-3'>The Track API</a></li>\n<li><a href='#!/guide/advance-section-4'>Track Cross Domain Scripts</a></li>\n<li><a href='#!/guide/advance-section-5'>Script error</a></li>\n<li><a href='#!/guide/advance-section-6'>Override Console</a></li>\n<li><a href='#!/guide/advance-section-7'>Helpers</a></li>\n</ol>\n</div>\n\n<p>Below are some advance techniques to capture exceptions.</p>\n\n<p>First create a logger object</p>\n\n<pre><code>var project = debuggify.Logger.get('project');\n</code></pre>\n\n<h2 id='advance-section-1'>The Report API</h2>\n\n<p>  We can wrap our code inside <strong>try-catch</strong> so it breaks we can extract information like filename, line no, char no and stacktrace from the exception.</p>\n\n<pre><code>function foo() {\n  try {\n    throw new Error(\"Something went wrong\");\n  } catch(e) {\n\n    // We can manually report this exception\n    project.report(e);\n\n  }\n}\n\nfoo();\n</code></pre>\n\n<p>  All you need to do is to pass the exception to the api, it will take care of extracting the information and reporting it.</p>\n\n<h2 id='advance-section-2'>The Big Try-Catch</h2>\n\n<p>  To catch errors in a particular javascript file, wrap the whole code inside a single try-catch. Executing the code inside the try catch can have some performance issues in browsers like chrome, so to do it efficiently</p>\n\n<pre><code>var __my_code__ = function {\n\n  // Whole javascript code here ...\n\n}\n\ntry {\n  __my_code__();\n} catch(e) {\n  // Now any exception thrown inside this code will be reported\n  project.report(e);\n}\n</code></pre>\n\n<h2 id='advance-section-3'>The Track API</h2>\n\n<p>This will <strong>wrap multiple</strong> functions at once for any json object.</p>\n\n<p>First create a human object</p>\n\n<pre><code>var Human = {\n\n  name: \"Anonmous\",\n\n  eyes: {\n    see : function() {\n      throw new Error(\"Something went wrong while seeing\");\n    },\n\n    blink : function() {\n      throw new Error(\"Something went wrong while blinking\");\n    },\n  },\n\n  talk : function() {\n    throw new Error(\"Something went wrong while talking\");\n  },\n\n  run: function() {\n    throw new Error(\"Something went wrong while running\");\n  },\n\n  walk : function() {\n    throw new Error(\"Something went wrong while walking\");\n  }\n};\n</code></pre>\n\n<p>Now, To automatic enable the error tracking inside the functions</p>\n\n<pre><code>// All the 1st level functions and their children functions will be wrapped\n// talk run walk are wrapped\n// see blink will not be wrapped\nproject.track(Human);\n\n// Only walk and run will be wrapped\nproject.track(bar, ['walk', 'run']);\n\n// To track children objects Human.eyes\n// see blink will be wrapped\nproject.track(Human.eyes);\n</code></pre>\n\n<p>So, now errors will be reported automatically</p>\n\n<pre><code>Human.walk();\n</code></pre>\n\n<p>We often have to work with big objects which have multilevel of hierarchy of functions. So we need to track all the sub level functions.</p>\n\n<pre><code>// Lets extend the Human object\n\nHuman.talk.to = function(name) {\n  throw new Error(\"Something went wrong while talking  to \" + name);\n};\n\nHuman.talk.via = function(device) {\n  throw new Error(\"Something went wrong while talking  via \" + device);\n};\n\n// The same will track errors for to and from.\n// Need need to add extra tracking\nproject.track(Human);\n</code></pre>\n\n<p><strong>NOTE</strong>: This will only wrap the functions while are immediate children not the prototype chain functions</p>\n\n<p>To check whether a function is currently tracked or not</p>\n\n<pre><code>project.isTracked(Human.talk.to); // return true\n</code></pre>\n\n<h3>Using with Jquery</h3>\n\n<pre><code>// All methods of bar will be wrapped\nproject.track(jQuery);\n\n// Only the mentioned functions will be wrapped\nproject.track(jQuery, ['extend', 'trim', 'hasData', 'css' ]);\n</code></pre>\n\n<p>For more details on debugging jQuery, see <a href=\"#!/guide/frameworks\">frameworks section</a></p>\n\n<h3>Disable Try-Catch wrapper</h3>\n\n<pre><code>// For all the functions\nproject1.untrack(bar);\n\n// For only mentioned function names\nproject1.untrack(bar, ['extend', \"trim\"]);\n</code></pre>\n\n<p>This will restore the original functions. This will work only if the function is already wrapped.</p>\n\n<h2 id='advance-section-4'>Track Cross Domain Scripts</h2>\n\n<p>The are many different techniques to track cross domain scripts</p>\n\n<h3>Fetch the javascript from the same origin as the current page.</h3>\n\n<p>For your own code its easy to host it on the same domain or setup a proxy which fetches the cross domain scripts and serve them. This may not play well with third party scripts as they further load many other scripts.</p>\n\n<h3>Wrap whole file inside try-catch</h3>\n\n<p>For this technique you have to modify your existing javascript code. When the code is wrapped inside try-catch the exception is caught inside catch loop. Every browser gives exact information at this point. So its easy to extract the exact information at this point of time. Check <a href=\"#!/guide/advance-section-2\">The Big Try-Catch</a> to know more.</p>\n\n<h3>Wrap the interfacing functions of the objects provided by that javascript</h3>\n\n<p>This means wrapping all the functions which are called externally with try-catch. You can manually go and update every function which is definitely hard to maintain. The good way is to use  <a href=\"#!/guide/advance-section-3\">The Track Api</a> which wrap all the functions of a object in line of code.</p>\n\n<h2 id='advance-section-5'>Script error</h2>\n\n<h3>What does it mean?</h3>\n\n<p>When some exception occurs for any cross origin script, some browser do not allow to collect the actual error information through window.onerror. In this cases the error message returned is \"Script error\".</p>\n\n<p>As per <a href=\"http://stackoverflow.com/questions/5913978/cryptic-script-error-reported-in-javascript-n-chrome-and-firefox/7778424#7778424\">stackoverflow</a> post this behavior is intentional to avoid some security risks but its at expense of useful debugging information.</p>\n\n<h3>I am not using any third party code then why I am seeing it ?</h3>\n\n<p>If the script is hosted on a different origin than the current page origin. Basically if anything among protocol, subdomain or port is different then its treated as different origin. This even happens if you are using CDN's to serve the static resources.</p>\n\n<h3>How to get actual error message</h3>\n\n<p>Check <a href=\"#!/guide/advance-section-4\">Track Cross Domain Scripts</a></p>\n\n<h2 id='advance-section-6'>Override Console</h2>\n\n<p>In production, We can easily capture console messages. And not only that, we can manage which type of message we want to capture.</p>\n\n<p>Lets override console in a single line.</p>\n\n<pre><code>window.console = debuggify.Logger.get('console');\n\n// We can console object to report errors\nconsole.info('Yay! I can collect console messages')\nconsole.log('Yay! I can collect console messages');\nconsole.warn('Yay! I can collect console messages');\nconsole.error('Yay! I can collect console messages');\n</code></pre>\n\n<p>This will send all types of messages to the server. But collecting info and log is not important so to limit it to receive only warn and error messages</p>\n\n<pre><code>window.console.setLevel(2);\n</code></pre>\n\n<p>Calling <code>setLevel</code> will only send messages which are greater than and equal to mentioned level.</p>\n\n<p>We can also use selFlag to enable / disable any specific level.</p>\n\n<pre><code>// Disable info messages\nwindow.console.setFlag('info', false);\n\n// Enable info messages\nwindow.console.setFlag('info', false);\n</code></pre>\n\n<h2 id='advance-section-7'>Helpers</h2>\n\n<h3>SetTimeout &amp; SetInterval</h3>\n\n<p>We have wrapped <code>setTimeout</code> and <code>setInterval</code> by default so any exceptions happens though their callbacks will be captured automatically.</p>\n\n<h3>Jquery Ajax Helper</h3>\n\n<pre><code>// A simple ajax helper to track ajax errors\n$(document).ajaxError(function(event, jqXHR, ajaxSettings, thrownError) {\n\n  project.error(thrownError);\n\n});\n</code></pre>\n\n<p>In future we will be integrating it in the debuggify js file to automatically capture ajax errors.</p>\n","title":"Advance Techniques"});